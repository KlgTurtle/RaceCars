
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 1</title>
    <script src="Phaser/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>

<body>

    <script type="text/javascript">
        class MapBitMap {
            constructor(WorldWidth, WorldHeight, TileWidth, TileHeight) {
                this.WorldWidth = WorldWidth;
                this.WorldHeight = WorldHeight;
                this.TileWidth = TileWidth;
                this.TileHeight = TileHeight;
                this.BitMap = [];
                this.nWidthSlots = Math.floor(this.WorldWidth / this.TileWidth);
                this.nHeightSlots = Math.floor(this.WorldHeight / this.TileHeight);
                for (let i = 0; i < this.nHeightSlots; ++i) {
                    this.BitMap[i] = [];
                    for (let j = 0; j < this.nWidthSlots; ++j) {
                        this.BitMap[i][j] = false;
                    }
                }
            }
            IsSlotOccupied(x, y) {
                let HeightIndex = Math.floor(y / this.TileHeight);
                let WidthIndex = Math.floor(x / this.TileWidth);
                if (HeightIndex >= this.nHeightSlots || WidthIndex >= this.nWidthSlots) debugger;
                return this.BitMap[HeightIndex][WidthIndex];
            }
            OccupySlot(x, y) {
                let HeightIndex = Math.floor(y / this.TileHeight);
                let WidthIndex = Math.floor(x / this.TileWidth);
                if (HeightIndex >= this.nHeightSlots || WidthIndex >= this.nWidthSlots) debugger;
                this.BitMap[HeightIndex][WidthIndex] = true;
            }
            FreeSlot(x, y) {
                let HeightIndex = Math.floor(y / this.TileHeight);
                let WidthIndex = Math.floor(x / this.TileWidth);
                if (HeightIndex >= this.nHeightSlots || WidthIndex >= this.nWidthSlots) debugger;
                this.BitMap[HeightIndex][WidthIndex] = false;
            }
        }
        class RaceTrack {
            constructor(TrackTileLayer) {
                this.TrackTileLayer = TrackTileLayer;
                this.MaxTileId = -1;
                var StartLineTile = this.TrackTileLayer.findTile(t => t.properties.startLine == true);
                // StartLineTile.tint = 0xaabbcc;
                var CurrDirX, CurrDirY;
                if (StartLineTile.properties.direction == 'x') {
                    CurrDirX = 1;
                    CurrDirY = 0;
                }
                else {
                    CurrDirX = 0;
                    CurrDirY = -1;
                }
                StartLineTile.properties.TileId = 0;
                var PrevTile = StartLineTile;
                var CurrTile = this.TrackTileLayer.getTileAt(StartLineTile.x + CurrDirX, StartLineTile.y + CurrDirY);
                var bLooped = false;
                do {
                    if (CurrTile.properties.TileId == -1) {
                        CurrTile.properties.TileId = PrevTile.properties.TileId + 1;
                    }
                    else {
                        this.MaxTileId = PrevTile.properties.TileId;
                        bLooped = true;
                    }
                    PrevTile.properties.nextTileId = CurrTile.properties.TileId;
                    PrevTile = CurrTile;
                    if (PrevTile.properties.turn) {
                        var temp = CurrDirX;
                        CurrDirX = CurrDirY;
                        CurrDirY = temp;
                    }
                    CurrTile = this.TrackTileLayer.getTileAt(PrevTile.x + CurrDirX, PrevTile.y + CurrDirY);
                    if (CurrTile == null) {
                        CurrDirX *= -1;
                        CurrDirY *= -1;
                        CurrTile = this.TrackTileLayer.getTileAt(PrevTile.x + CurrDirX, PrevTile.y + CurrDirY);
                    }
                } while (!bLooped)
            }
        }
        class RaceCar {
            constructor(SceneObj, x, y, TileSize, TileScale, raceTrack, ImageNameCar, ImageNameArrow) {
                this.Car = SceneObj.matter.add.image(x + RaceCar.StartLineDeltaX + (TileSize / 2) * TileScale,
                    y + RaceCar.StartLineDeltaY + (TileSize / 2) * TileScale, ImageNameCar);
                this.Car.setFrictionAir(0.03);
                this.TileSize = TileSize;
                this.TileScale = TileScale;
             //  this.Car.setFrictionStatic(1);
                this.Car.setMass(1.5);
                this.WheelDir = 0;
                this.Car.setScale(1.8);
              //  this.Car.body.setAngularDrag(0.1);
                // this.OffTrackArrow.setScrollFactor(0.99,0.99);
                //   this.OffTrackArrow.setScale(0.25);
                this.raceTrack  = raceTrack;
                this.LapsCompleted = 0;
                this.Place = 0;
                this.Power = 0;
                this.CompletedRace = false;
                this.TimeLeftTrack = 0;
                this.LastValidTile = null;
                this.LastValidX = this.Car.x;
                this.LastValidY = this.Car.y;
                this.OnTrack = true;
                this.alphaFactor = 1;
                this.OffTrackTimerId = 0;
                this.graphics = SceneObj.add.graphics({ fillStyle: { color: 0x00ff00 }, lineStyle: { color: 0x00ff00 } });
                this.offTrackPointer = new Phaser.Geom.Triangle;
                if (RaceCar.StartLineDeltaX == RaceCar.StartLineDeltaY) {
                    RaceCar.StartLineDeltaY -= (TileSize / 2) * TileScale;
                }
                else {
                    RaceCar.StartLineDeltaX -= (TileSize / 2) * TileScale;
                }
                SceneObj.events.once('offTrack', this.handleOffTrack, this);
            }
            ShowOffTrackArrow(RaceCarObj, SceneObj) {
                // vector directed from the car to the last valid tile
                var vDir = new Phaser.Math.Vector2(RaceCarObj.LastValidX - RaceCarObj.Car.x,
                    RaceCarObj.LastValidY - RaceCarObj.Car.y);
                vDir.normalize();
                var vDirPerp = new Phaser.Math.Vector2(-vDir.y, vDir.x);
                var trX = 0, trY = 0;
                var trVec;
                var vDirAngle = vDir.angle();
                // TOP
                if (vDirAngle >= 5 * Math.PI / 4 && vDirAngle <= 7 * Math.PI / 4) {
                    trY = 0;
                    var factor = (SceneObj.game.config.height / 2) / vDir.y;
                    trX = SceneObj.game.config.width / 2 - vDir.x * factor;
                }
                // RIGHT
                else if (vDirAngle >= 7 * Math.PI / 4 || vDirAngle <= Math.PI / 4) {
                    trX = SceneObj.game.config.width;
                    var factor = (SceneObj.game.config.width / 2) / vDir.x;
                    trY = SceneObj.game.config.height / 2 + vDir.y * factor;
                }
                // BOTTOM
                else if (vDirAngle >= Math.PI / 4 && vDirAngle <= 3 * Math.PI / 4) {
                    trY = SceneObj.game.config.height;
                    var factor = (SceneObj.game.config.height / 2) / vDir.y;
                    trX = SceneObj.game.config.width / 2 + vDir.x * factor;
                }
                // LEFT (or as Sherlock Holmes said...)
                else // if (vDirAngle >= 3*Math.PI/4 && vDirAngle <= 5*Math.PI/4)
                {
                    trX = 0;
                    var factor = (SceneObj.game.config.width / 2) / vDir.x;
                    trY = SceneObj.game.config.height / 2 - vDir.y * factor;
                }
                //  trX = Math.min(Math.max(trX, 0), SceneObj.game.config.width);
                //  trY = Math.min(Math.max(trY, 0), SceneObj.game.config.height);
                vDir.scale(40);
                vDirPerp.scale(10);
                SceneObj.events.emit('ShowOffTrackArrow', trX, trY, vDirAngle);
            }
            handleOffTrackInterval(RaceCarObj, SceneObj) {
                if (!RaceCarObj.OnTrack && RaceCarObj.LastValidTile) {
                    if ((RaceCarObj.alphaFactor > 0 && RaceCarObj.LastValidTile.alpha >= 1) ||
                        (RaceCarObj.alphaFactor < 0 && RaceCarObj.LastValidTile.alpha <= 0.7)) {
                        RaceCarObj.alphaFactor *= -1;
                    }
                    RaceCarObj.LastValidTile.setAlpha(RaceCarObj.LastValidTile.alpha + 0.05 * RaceCarObj.alphaFactor);
                    if (!Phaser.Geom.Rectangle.Contains(SceneObj.cameras.main.worldView, RaceCarObj.LastValidX, RaceCarObj.LastValidY)) {
                        RaceCarObj.ShowOffTrackArrow(RaceCarObj, SceneObj);
                    }
                    else {
                        SceneObj.events.emit('HideOffTrackArrow');
                    }
                }
                else {
                    RaceCarObj.LastValidTile.clearAlpha();
                    clearInterval(RaceCarObj.OffTrackTimerId);
                    SceneObj.events.emit('HideOffTrackArrow');
                    SceneObj.events.once('offTrack', RaceCarObj.handleOffTrack, RaceCarObj);
                }
            }
            handleOffTrack(RaceCarObj, SceneObj) {
                RaceCarObj.OffTrackTimerId = setInterval(RaceCarObj.handleOffTrackInterval, 50, RaceCarObj, SceneObj);
            }
            debug(SceneObj) {
                text.setPosition(100 - SceneObj.cameras.main.x, 100 - SceneObj.cameras.main.y);
                text.setText([
                    'position.x: ' + this.Car.body.position.x,
                    'position.y: ' + this.Car.body.position.y,
                    'velocity.x: ' + this.Car.body.velocity.x,
                    'velocity.y: ' + this.Car.body.velocity.y,
                    'camrea.x:' + SceneObj.cameras.main.x,
                    'camera.y:' + SceneObj.cameras.main.y
                ]);
            }
            checkTileValidity(SceneObj, T) {
                this.graphics.clear();
                var factor = 1;
                if (T != null && ((this.LastValidTile == null) ||
                    (this.LastValidTile.properties.TileId == T.properties.TileId) ||
                    ((this.LastValidTile.properties.TileId != T.properties.TileId) &&
                        this.LastValidTile.properties.nextTileId == T.properties.TileId))) {
                    if (this.OnTrack) {
                        this.LastValidTile = T;
                        this.LastValidX = this.Car.x;
                        this.LastValidY = this.Car.y;
                    }
                    else if (this.LastValidTile.properties.TileId == T.properties.TileId) {
                        this.OnTrack = true;
                    }
                    return factor;
                }
                factor = (T == null) ? factor/2 : factor;
                if (this.LastValidTile != null) {
                    // We're not on track, if we're far enough we'll trigger the "off track" event.
                    if (T == null) {
                        this.OnTrack = false;
                        var FoundTiles = trackLayer.getTilesWithinShape(new Phaser.Geom.Circle(this.Car.x, this.Car.y, SceneObj.game.config.height / 6),
                            { isNotEmpty: true });
                        if (FoundTiles.length == 0) 
                        {
                            SceneObj.events.emit('offTrack', this, SceneObj);
                        }
                        else
                        {

                            var N1ValidTile = trackLayer.findTile(t => t.properties.TileId == this.LastValidTile.properties.nextTileId);
                            var DistToNext = Phaser.Math.Distance.Between(this.Car.x, this.Car.y, 
                            N1ValidTile.getCenterX(), N1ValidTile.getCenterY());
                            var DistToLast = Phaser.Math.Distance.Between(this.Car.x, this.Car.y, 
                            this.LastValidTile.getCenterX(), this.LastValidTile.getCenterY());

                            // if we're closer to the next valid tile than to the last valid one and also close enough, update last valid tile
                            if (DistToNext < this.TileSize*this.TileScale*1.5)
                            {
                                this.LastValidTile.clearAlpha();
                                this.LastValidTile = N1ValidTile;
                            }
                            else debugger;
                        }
                    }
                    // We're on track, make sure that we're on a valid tile, or on a close enough tile, otherwise trigger "off track" event.
                    else {
                        var FoundTiles = trackLayer.getTilesWithinShape(
                            new Phaser.Geom.Circle(this.LastValidTile.getCenterX(), this.LastValidTile.getCenterY(), 
                        SceneObj.game.config.height / 6),
                            { isNotEmpty: true });
                        

                        // var N1ValidTile = trackLayer.findTile(t => t.properties.TileId == this.LastValidTile.properties.nextTileId);
                        // var N2ValidTile = trackLayer.findTile(t => t.properties.TileId == N1ValidTile.properties.nextTileId);
                        // var N3ValidTile = trackLayer.findTile(t => t.properties.TileId == N2ValidTile.properties.nextTileId);
                        // if (T.properties.TileId == N1ValidTile.properties.TileId ||
                        //     T.properties.TileId == N2ValidTile.properties.TileId ||
                        //     T.properties.TileId == N3ValidTile.properties.TileId) {
                        //     this.LastValidTile.clearAlpha();
                        //     this.LastValidTile = T;
                        //     this.OnTrack = true;
                        // }
                        // if (FoundTiles.length > 0)
                        // {
                        //     var found = false;
                        //     for (let i = 0; i < FoundTiles.length; ++i)
                        //     {
                        //         if ((FoundTiles[i].TileId == T.TileId) && 
                        //         (((T.TileId - FoundTiles[i].properties.TileId) % this.raceTrack.MaxTileId) <= 6))
                        //         {
                        //             this.LastValidTile.clearAlpha();
                        //             this.LastValidTile = T;
                        //             this.OnTrack = true;
                        //             break;
                        //         }
                        //     }
                        //     if (!found)
                        //     {
                        //         this.OnTrack = false;
                        //         SceneObj.events.emit('offTrack', this, SceneObj);
                        //     }
                            
                        // }
                        if (((T.properties.TileId - this.LastValidTile.properties.TileId) % this.raceTrack.MaxTileId) < 6) 
                        {
                            this.LastValidTile.clearAlpha();
                            this.LastValidTile = T;
                            this.OnTrack = true;
                        }
                        else
                        {
                            this.OnTrack = false;
                            SceneObj.events.emit('offTrack', this, SceneObj);
                        }
                    }
                }
                return factor;
            }
            update(SceneObj) {
                this.debug(SceneObj);
                var origX = this.Car.x;
                var origY = this.Car.y;
                var CurrTile = trackLayer.getTileAt(trackLayer.worldToTileX(origX), trackLayer.worldToTileY(origY));
                var point1 = this.Car.getTopLeft();
                var point2 = this.Car.getBottomLeft();
                var point3 = this.Car.getTopRight();
                var point4 = this.Car.getBottomRight();
                var FrontCenter = new Phaser.Math.Vector2({x: (point3.x + point4.x) / 2, y: (point3.y + point4.y) / 2});
                
                var FrontL2R = new Phaser.Math.Vector2().copy(point4).subtract(point3).normalize();
                var BackR2L = new Phaser.Math.Vector2().copy(point2).subtract(point1).normalize();
                var Front2Back1 = new Phaser.Math.Vector2().copy(point3).subtract(point1).normalize();
                var Front2Back2 = new Phaser.Math.Vector2().copy(point4).subtract(point2).normalize();

              //  var Front = new Phaser.Math.Vector2({x: (FrontCenter.x + this.Car.getCenter().x)/2,
              //   y: (this.Car.getCenter().y + FrontCenter.y)/2 });
              var Front = FrontCenter.clone().subtract(Front2Back1.clone().scale(0.25*this.Car.body.displayWidth));
            //    var VecLF2RF = new Phaser.Math.Vector2({x: point4.x - point3.x, y: point4.y - point3.y});
                
                //var angle = { x: speed * Math.cos(this.Car.body.angle), y: speed * Math.sin(this.Car.body.angle) };
                // var angle = { x: 0, y: 0 };
                var powerFactor = this.checkTileValidity(SceneObj, CurrTile);
                //this.Car.body.drag = dragFactor;
         
                var factor = 0.00005;
                if (cursors.left.isDown)
                {
                    this.WheelDir = Math.min(this.WheelDir + 0.25, 1);
                }
                if (cursors.right.isDown)
                {
                    this.WheelDir = Math.max(this.WheelDir - 0.25, -1);
                }
                if (this.WheelDir != 0)
                {
                    
                    this.Car.applyForceFrom(FrontCenter, FrontL2R.clone().scale(-this.Car.body.speed*this.Car.body.speed*this.WheelDir/200000));
                   // var forceVec = new Phaser.Math.Vector2({x:this.Car.body.force.x,y: this.Car.body.force.y});
                //    this.Car.rotation += this.WheelDir/1000;
            //    this.Car.body.angularSpeed = 0.1;
             //       this.Car.body.angularVelocity = Math.sqrt((forceVec.length()/this.Car.body.mass)*Math.abs(this.WheelDir)*10000);
            //        this.Car.body.angle += this.WheelDir;
                   // this.Car.applyForceFrom(this.Car.getCenter(), FrontL2R.clone().scale(-this.Car.body.speed*this.Car.body.speed*this.WheelDir/3));
                }
           
        //         if (cursors.left.isDown) {
        //             this.Car.applyForceFrom(point3, FrontL2R.clone().scale(-Math.min(0.005,this.Car.body.speed/1000))); 
           
        //             this.Car.applyForceFrom(point1, BackR2L.clone().scale(Math.min(0.005,this.Car.body.speed/1000))); 
              
        //         }
        //         else if (cursors.right.isDown) {
        //             this.Car.applyForceFrom(point3, FrontL2R.clone().scale(Math.min(0.005,this.Car.body.speed/1000))); 
           
        //    this.Car.applyForceFrom(point1, BackR2L.clone().scale(-Math.min(0.005,this.Car.body.speed/1000)));

        //         }
                if (cursors.up.isDown) 
                {
                    this.Power = Math.min(this.Power + 3, 25);
                 
  
                }
                else if (cursors.down.isDown) {
                    this.Car.applyForceFrom({ x: point1.x, y: point1.y }, {
                        x: -factor * (point3.x - point1.x),
                        y: -factor * (point3.y - point1.y)
                    });
                    this.Car.applyForceFrom({ x: point2.x, y: point2.y }, {
                        x: -factor * (point4.x - point2.x),
                        y: -factor * (point4.y - point2.y)
                    });
                }
                else if (this.Power > 0)
                {
                    this.Power /= 1.01;
                }
                if (!cursors.left.isDown && !cursors.right.isDown && this.WheelDir != 0)
                    {
                    //  var vForwardDir = (point3 - point1).normalize();
                       // var vSidewaysDir = point4.subtract(point3).normalize();
                     //   var vVelSideways = vSidewaysDir.dot({x: this.Car.body.velocity.x, y: this.Car.body.velocity.y});
                          if (this.Car.body.angularVelocity > 0.01)
                          {
                              this.Car.applyForceFrom({ x: point3.x, y: point3.y },FrontL2R.clone().scale(-0.003));
                          }
                          else if (this.Car.body.angularVelocity < -0.01)
                          {
                              this.Car.applyForceFrom({ x: point3.x, y: point3.y },FrontL2R.clone().scale(0.003));
                          }
                        
                        
                            this.WheelDir /= 2000;
                            if (Math.abs(this.WheelDir) < 0.0001)
                            {
                                this.WheelDir = 0;
                            }
                        

                    }

                 this.Car.applyForceFrom(point1,Front2Back1.clone().scale(powerFactor*this.Power*0.0005));
                 this.Car.applyForceFrom(point2, Front2Back2.clone().scale(powerFactor*this.Power*0.0005));
                // SceneObj.cameras.main.x = ((game.config.width / 2 - this.Car.x < 0) && (this.Car.x - (worldWidth - game.config.width / 2) < 0)) ? game.config.width / 2 - this.Car.x : SceneObj.cameras.main.x;
                //   SceneObj.cameras.main.y = ((game.config.height / 2 - this.Car.y < 0) && (this.Car.y - (worldHeight - game.config.height / 2) < 0)) ? game.config.height / 2 - this.Car.y : SceneObj.cameras.main.y;
            }
        }
        RaceCar.StartLineDeltaX = 0;
        RaceCar.StartLineDeltaY = 0;
        worldWidth = 16500;
        worldHeight = 16500;
        var scaleSize = 2.2;
        var stepSize = 128 * scaleSize;
        var mapBitMap = new MapBitMap(worldWidth, worldHeight, stepSize, stepSize);
        var car1, car2;
        var tracker1;
        var tracker2;
        var cursors;
        var TileScale = 11;
        var map;
        var trackLayer;
        var text;
        function createCars(gameObj, x, y, TileSize, raceTrack) {
            car1 = new RaceCar(gameObj, x, y, TileSize, TileScale, raceTrack, 'car', 'GreenArrow');
            //  car2 = new RaceCar(gameObj, x, y, TileSize, TileScale, 'car');
        }
        function isSlotOccupied(arr, x, y, step) {
            return (arr[Math.floor(x / step)][Math.floor(y / step)]);
        }
        function markSlot(arr, x, y, step) {
            arr[Math.floor(x / step)][Math.floor(y / step)] = 1;
        }
        function setCarTracker(sceneObj) {
            tracker1 = new Phaser.Geom.Rectangle(0, 0, 4, 4);
            tracker2 = new Phaser.Geom.Rectangle(0, 0, 4, 4);
            tracker3 = new Phaser.Geom.Rectangle(0, 0, 4, 4);
            tracker4 = new Phaser.Geom.Rectangle(0, 0, 4, 4);
            graphics1 = sceneObj.add.graphics({ fillStyle: { color: 0x0000ff } });
            graphics2 = sceneObj.add.graphics({ fillStyle: { color: 0x00ff00 } });
            graphics3 = sceneObj.add.graphics({ fillStyle: { color: 0xff0000 } });
            graphics4 = sceneObj.add.graphics({ fillStyle: { color: 0xffff00 } });
        }
        class GameScene extends Phaser.Scene {
            constructor() {
                super('GameScene');
            }
            preload() {
                this.load.image('soil', 'assets/textures/soil.png');
                this.load.image('car', 'assets/sprites/car-yellow.png');
                this.load.image('road', 'assets/textures/road2.png');
                this.load.image('roadVertical', 'assets/Tiles/Asphalt road/road_asphalt01.png');
                this.load.image('roadHorizontal', 'assets/Tiles/Asphalt road/road_asphalt02.png');
                this.load.image('turnUpRight', 'assets/Tiles/Asphalt road/road_asphalt03.png');
                this.load.image('turnUpLeft', 'assets/Tiles/Asphalt road/road_asphalt05.png');
                this.load.image('turnDownRight', 'assets/Tiles/Asphalt road/road_asphalt39.png');
                this.load.image('turnDownLeft', 'assets/Tiles/Asphalt road/road_asphalt41.png');
                // this.load.image("trackTiles", 'assets/Spritesheets/spritesheet2.png');
                this.load.spritesheet('trackTiles', 'assets/Spritesheets/new/AssetPack/road.png', { frameWidth: 88, frameHeight: 88 });
                this.load.tilemapTiledJSON("map", 'assets/Spritesheets/new/level1.json');
            }
            create() {
                this.add.tileSprite(worldWidth / 2, worldHeight / 2, worldWidth, worldHeight, 'soil');
                this.cameras.main.roundPixels = true;
                map = this.make.tilemap({ key: "map" });
                const tileset = map.addTilesetImage("Road", "trackTiles", 88, 88, 1, 2);
                trackLayer = map.createDynamicLayer(0, tileset, 0, 0);
                trackLayer.setScale(TileScale);
                trackLayer.setCollisionFromCollisionGroup();
                //   map.setCollisionByExclusion([-1,9]);
                console.log(tileset.tileProperties);
                trackLayer.setCollisionByProperty({ collides: true });
                this.matter.world.convertTilemapLayer(trackLayer);
                var tile = trackLayer.findTile(t => t.index == 7);
                var raceTrack = new RaceTrack(trackLayer);
                createCars(this, tile.getCenterX(), tile.getCenterY(), tile.height, raceTrack);
                this.matter.world.setBounds(0, 0, worldWidth, worldHeight);
              
                this.cameras.main.setBounds(0, 0, worldWidth, worldHeight);
                setCarTracker(this);
                cursors = this.input.keyboard.createCursorKeys();
                text = this.add.text(100, 100, '', { font: '16px Courier', fill: '#00ff00' });
                this.cameras.main.startFollow(car1.Car, true);
                this.cameras.main.zoom = 0.27;
            }
            update() {
                car1.update(this);
                // car2.update(this);
            }
        }
        class UIScene extends Phaser.Scene {
            constructor() {
                super({ key: 'UIScene', active: true });
                this.OffTrackArrow = null;
            }
            preload() {
                this.load.image('GreenArrow', 'assets/Spritesheets/new/AssetPack/arrowGreen.png');
            }
            create() {
                this.OffTrackArrow = this.matter.add.sprite(0, 0, 'GreenArrow');
                this.OffTrackArrow.setActive(false);
                this.OffTrackArrow.setVisible(false);
                //  Grab a reference to the Game Scene
                let ourGame = this.scene.get('GameScene');
                //  Listen for events from it
                ourGame.events.on('ShowOffTrackArrow', function (trX, trY, vDirAngle) {
                    this.OffTrackArrow.setVisible(true);
                    let gameheight = this.game.config.height;
                    let gamewidth = this.game.config.width;
                    this.OffTrackArrow.x = Math.min(gamewidth - this.OffTrackArrow.width / 2, Math.max(this.OffTrackArrow.width / 2, trX));
                    this.OffTrackArrow.y = Math.min(gameheight - this.OffTrackArrow.height / 2, Math.max(this.OffTrackArrow.height / 2, trY));
                    this.OffTrackArrow.setRotation(Math.PI / 2 + vDirAngle);
                }, this);
                ourGame.events.on('HideOffTrackArrow', function () {
                    this.OffTrackArrow.setVisible(false);
                }, this);
            }
        }
        var config = {
            type: Phaser.AUTO,
            width: 1800,
            height: 1200,
            physics: {
                default: 'matter',
                matter: {
                    debug: true,
                    gravity: {
                        x: 0,
                        y: 0
                    }
                }
            },
            // scene: {
            //      preload: preload,
            //      create: create,
            //       update: update
            //   },
            scene: [GameScene, UIScene],
            pixelArt: true
        };
        const TOP = 1;
        const LEFT = 2;
        const BOTTOM = 3;
        const RIGHT = 4;
        var game = new Phaser.Game(config);
    </script>

</body>

</html>
